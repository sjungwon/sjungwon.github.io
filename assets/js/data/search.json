[ { "title": "템플릿 메소드", "url": "/posts/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%86%8C%EB%93%9C/", "categories": "자바, 디자인패턴", "tags": "자바, 디자인패턴, 템플릿메소드, 훅", "date": "2022-08-26 16:04:00 +0900", "snippet": "템플릿 메서드 패턴 추상 메서드를 배우던 중 디자인 패턴이 나와 정리해두려고 작성한다. 템플릿 메서드에 대한 자세한 내용은 참고 블로그를 보면 있다. 템플릿 메서드는 시작부터 끝사이의 동작들과 같이 어떤 수행해야할 로직들을 덩어리로 미리 정의해놓는 것이다. 템플릿 메서드는 훅 메서드와 같이 사용하는데 훅 메서드는 템플릿 메서드의 수행 로직 사이에 어떤 추가 로직을 넣을 수도 있겠다 싶은 곳에서 사용한다. 아무 내용 없는 훅 메서드를 정의하고 실행 흐름 사이에서 호출해놓는다. 이후 하위 클래스에서 실행 로직 중간에 추가 로직을 구현하려 할 때 훅 메서드를 오버라이딩해서 작성해주면 된다. 아래 코드를 보면 전자레인지를 추상 클래스로 선언했다. 전자레인지의 일반적인 동작을 start에 작성했다. 문을 닫고, 판을 회전시키면서 전자파를 쏘고, 완료시 문을 연다. 이러한 동작은 어떤 전자레인지라도 동일한 동작일테니 실행 흐름 자체를 하나의 템플릿처럼 작성할 수 있다. 문을 닫고 판을 회전시키기 전에 어떤 동작을 할 수 있을 것이고, 회전하면서 전자파를 쏘는 중에도 어떤 동작을 할 수 있고, 완료시에도 추가적인 동작이 있을 수 있다. 이럴 때 사용하는 것이 훅 메서드이다. 훅 메서드는 아무 내용이 없는 메서드를 선언해두고 실행 흐름(템플릿 메서드)에 끼워서 실행해둔다. 실제 해당 메서드를 구현해 사용하려는 하위 클래스가 있다면 하위 클래스쪽에서 구현하도록 하는 것이다. 훅 메서드가 추상 메서드와 다른 점은 추상 메서드는 선언해두면 하위 클래스에서 사용하지 않더라도 항상 구현해야한다. 훅 메서드는 사용하려는 하위 클래스 쪽에서만 구현하면 된다. 이러한 패턴을 템플릿 메서드 패턴이라 한다.package com.company;public abstract class Microwave { protected int plateDeg = 0; private int temperature = 0; private boolean door = false; public void closeDoor(){ this.door = true; } public void openDoor(){ this.door = false; } public void beforeStart(){} public void spin(){ plateDeg = (plateDeg + 60) % 360; System.out.println(\"spin\"+plateDeg); } //훅 메서드 -&gt; 필요에 따라 구현(abstract 메서드인 경우엔 항상 구현해야함) public void ray(){ temperature += 3; System.out.println(\"ray\" + temperature); }; public void finish(){ this.plateDeg = 0; openDoor(); } //템플릿 메서드 패턴 - 실행 흐름 정의 final void start(){ closeDoor(); beforeStart(); if(door) { for (int i = 0; i &lt; 30; i++) { spin(); ray(); } } finish(); }}class OsungMicrowave extends Microwave{ public void beep(){ System.out.println(\"beep\"); } @Override public void beforeStart() { beep(); } public static void main(String[] args){ OsungMicrowave m = new OsungMicrowave(); m.start(); }} 아래의 코드는 리액트를 공부할 때 사용했던 state를 대략적으로 구현해봤다. 실제 리액트의 구현을 까보지 않았기에 동작만 비슷하게 구현했다. state 클래스로 선언했으며 state에 대한 setState를 템플릿 메서드로 구현했다. setState시에 상태 값 변경에 따른 추가 로직을 설정할 수 있게 useEffect 훅 메서드를 정의했다. PrevState 클래스는 state를 상속받은 클래스로 setState시에 이전 값을 저장하도록 useEffect를 구현했다.package com.company;import java.util.Objects;public abstract class State&lt;T&gt; { protected T val; public State(T val){ this.val = val; } //템플릿 메서드 패턴 public final void setState(T val){ //실행 흐름 정의 this.useEffect(); this.val = val; } //훅 메서드 public void useEffect(){};}class PrevState extends State&lt;String&gt;{ private String prev = null; public PrevState(String val){ super(val); this.prev = val; } public String getPrev(){ return this.prev; } @Override public void useEffect() { this.prev = this.val; }}class Main{ public static void main(String[] args){ PrevState p = new PrevState(\"first\"); System.out.println(\"val \" + p.val + \" prev \"+p.getPrev()); p.setState(\"second\"); System.out.println(\"val \" + p.val + \" prev \"+p.getPrev()); p.setState(\"third\"); System.out.println(\"val \" + p.val + \" prev \"+p.getPrev()); }}정리 구현하려는 객체가 여러가지로 구체화되는데 전체적인 동작이 동일한 경우 사용해볼 수 있을 것 같다. 전체적인 동작을 템플릿 메서드로 구현하고 중간 중간에 추가 로직이 필요한 경우 훅 메서드를 끼워넣고 하위 클래스 쪽에서 이를 구현해서 넣어서 구현해볼 수 있을 것 같다.참고템플릿 메서드 패턴이란" }, { "title": "자바 언어의 특징", "url": "/posts/%EC%9E%90%EB%B0%94%EC%96%B8%EC%96%B4%EC%9D%98-%ED%8A%B9%EC%A7%95/", "categories": "자바, 언어", "tags": "자바, JVM, 가비지컬렉터, 멀티스레드", "date": "2022-08-20 00:34:00 +0900", "snippet": "특징1. 운영체제에 독립적이다. 자바는 에뮬레이터의 일종인 자바가상머신(JVM)을 통해서 실행된다. JVM은 자바를 실행하기 위한 가상 컴퓨터 다른 언어는 OS를 거쳐 바로 하드웨어로 전달되는 것과 달리 자바는 JVM을 거치기 때문에 완전히 컴파일된 상태가 아니고 바이트코드로 변환되고 실행시에 해석되기 때문에 속도가 느리다는 단점이 있었음 바이트코드를 변환해주는 JIT컴파일러와 최적화 기술로 속도가 많이 빨라짐 다른 언어는 운영체제와 바로 통신하기 때문에 운영체제에 종속적이고 자바는 JVM과 통신하기 때문에 운영체제에 종속적이지 않음. 단, JVM은 운영체제에 종속적 자바는 JVM 위에서만 동작하기 때문에 JVM은 필수 자바로 작성한 프로그램은 하드웨어나 운영체제와 통신하지 않고 JVM하고 통신한다. JVM이 자바의 명령을 운영체제에 맞게 변환하여 실행한다. JVM은 운영체제와 통신해야하기 때문에 운영체제에 종속된다.2. 객체지향언어 상속, 캡슐화, 다형성 등의 객체지향의 특징이 잘 적용된 언어라는 평가가 있다.3. 자동 메모리 관리(가비지 컬렉터) 직접 메모리를 할당하고 해제해야하는 C같은 언어와 달리 가비지 컬렉터가 메모리를 관리해준다.4. 멀티스레드 지원 자바의 멀티스레드는 시스템과 상관없이 구현이 가능하며, 여러 쓰레드에 대한 스케줄링을 자바 인터프리터가 담당한다.5. 동적 로딩 지원 실행 시 모든 클래스를 로딩하지 않고 클래스가 필요한 순간에 로딩해서 사용할 수 있다. 일부 클래스가 변경되어도 전체를 컴파일하지 않아도 된다.주요 내용 .java 파일 -&gt; 컴파일 -&gt; .class 파일 -&gt; 실행 자바의 모든 코드는 클래스 내부에 존재해야함 자바 프로그램의 시작은 main 메서드를 시작점으로 main 메서드를 호출하는 것을 시작으로 메서드의 모든 코드 실행 후 종료된다. 따라서 자바 프로그램에선 main 메서드를 포함한 클래스가 반드시 하나는 있어야함 자바 프로그램을 실행할 땐 main 메서드를 포함한 클래스 이름을 명령어에 작성해야한다. 자바는 하나의 파일에 하나의 클래스를 보통 작성하지만 여러 개 작성도 가능 주의해야할 점은 소스파일의 이름은 public class의 이름과 일치해야하고 하나의 파일에선 하나의 public class만 존재해야함 파일에 public class가 없다면 아무 클래스 이름으로 파일 이름을 작성해도 됨 클래스 파일은 작성한 클래스마다 하나씩 생성됌변수 타입 변수명 순서로 작성 int a; 동일한 타입이면 여러 개 정의 가능 int a, b; 여러개 정의하면서 초기화도 가능 int a=0, b=1; 변수를 생성하면 쓰레기 값 들어있으므로 초기화하고 사용하는 것이 좋음 지역변수는 반드시 초기화해야함, 클래스 변수와 인스턴스 변수는 생략가능권장 규칙 클래스 이름의 첫 글자는 항상 대문자 여러 단어로 이루어진 이름은 단어의 첫글자를 대문자로 한다. 클래스는 첫글자도 대문자이므로 파스칼 케이스 다른건 첫글자 소문자이므로 카멜 케이스 상수 이름은 모두 대문자, 여러 단어를 구문할 때 “_“로 구분키워드 JVM 가비지컬렉터 멀티스레드참고자바의 정석 1편 - yes24 링크" }, { "title": "스프링 시작", "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%EC%9E%91/", "categories": "스프링", "tags": "", "date": "2022-08-20 00:26:00 +0900", "snippet": "스프링 공부 시작 typescript 기반의 Node로 서버 구현 경험을 했음 node의 express는 너무 자유롭고 nestjs는 틀이 꽤 있지만 관련된 자료가 부족한 것 같아 백엔드를 공부하기에 마음이 편하지 않았음 언어를 다시 공부해야하지만 스프링을 통해 객체 지향, 디자인 패턴 등에 익숙해진 후에 다시 사용해 보는 것이 마음이 편할 것 같아 스프링 공부를 시작" }, { "title": "이벤트루프", "url": "/posts/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%84/", "categories": "노드", "tags": "", "date": "2022-08-17 02:36:00 +0900", "snippet": "이벤트 루프란? 노드가 논 블로킹 I/O 작업을 수행할 수 있도록 이벤트 루프가 비동기가 가능하면 시스템 커널에 작업을 넘김 현대 커널은 멀티 스레드이므로 백그라운드에서 다수의 작업을 실행 가능 커널에서 작업을 완료하면 커널이 노드에게 완료를 알려주어 적잘한 콜백을 poll 큐에 추가할 수 있게함설명 노드를 시작할 때 이벤트 루프를 초기화하고 제공된 입력 스크립트를 처리 입력 스크립트에서는 비동기 API, 타이머, process.nextTick()을 호출 가능 이후 이벤트루프 처리를 시작함이벤트 루프 단계 ┌───────────────────────────┐┌─&gt;│ timers ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ pending callbacks ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ idle, prepare ││ └─────────────┬─────────────┘ ┌───────────────┐│ ┌─────────────┴─────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └─────────────┬─────────────┘ │ data, etc. ││ ┌─────────────┴─────────────┐ └───────────────┘│ │ check ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐└──┤ close callbacks │ └───────────────────────────┘ 공식 문서의 다이어그램 노드는 libuv의 이벤트 루프를 사용한다, 각 단계를 libuv와 비교해보면 libuv 루프 시작 -&gt; 만료된 타이머 콜백 실행 -&gt; pending handles -&gt; idle handles -&gt; prepare handles -&gt; poll for I/O -&gt; check handles -&gt; close callbacks -&gt; 반복 위 다이어 그램과 동일하다는 것을 알 수 있다. 각 단계는 실행할 콜백의 FIFO 큐를 가진다. 각 단계는 자신만의 방법에 제한적으로 이벤트 루프가 해당 단계에 진입하면 해당 단계에 한정된 작업을 수행 각 단계의 큐를 모두 소진하거나, 콜백의 최대 개수를 실행할 때까지 해당 단계의 큐에서 콜백을 실행. 큐를 모두 소진 혹은 최대 개수에 이르면 이벤트 루프는 다음 단계로 이동 각 작업이 또 다른 작업을 스케줄링하거나, poll 단계에서 처리된 새로운 이벤트가 커널에 의해 큐에 추가될 수 있으므로 폴링 이벤트를 처리하면서 poll 이벤트를 큐에 추가할 수 있다. 그 결과로 오래 실행되는 콜백은 poll 단계가 타이머 한계 시점보다 훨씬 더 오래 실행되도록 할 수 있다. libuv에서 poll 단계에 들어가기 전에 poll에서 사용할 시간을 설정함, 이후 poll에서 설정한 시간동안 루프가 멈추게 되는데 아마 이를 또 설정할 수 있는 듯 각 단계 개요 timers: 이 단계는 setTimeout()과 setInterval()로 스케줄링한 콜백을 실행합니다. pending callbacks: 다음 루프 반복으로 연기된 I/O 콜백들을 실행합니다. idle, prepare: 내부용으로만 사용합니다. poll: 새로운 I/O 이벤트를 가져옵니다. I/O와 연관된 콜백(클로즈 콜백, 타이머로 스케줄링된 콜백, setImmediate()를 제외한 거의 모든 콜백)을 실행합니다. 적절한 시기에 node는 여기서 블록 합니다. check: setImmediate() 콜백은 여기서 호출됩니다. close callbacks: 일부 close 콜백들, 예를 들어 socket.on(‘close’, …).각 단계 세부 내용 timers 타이머는 사람이 실행하기를 원하는 정확한 시간이 아닌 제공된 콜백이 일정 시간 후에 실행되어야 하는 기준 시간을 지정 타이머 콜백은 지정한 시간이 지난 후에 스케줄링 될 수 있는 가장 이른 시간에 실행됨 운영체제 스케줄링이나 다른 콜백 실행 때문에 지연될 수 있음 아래는 공식 문서의 예시 const fs = require(\"fs\");function someAsyncOperation(callback) { // 이 작업이 완료되는데 95ms가 걸린다고 가정합니다. fs.readFile(\"/path/to/file\", callback);}const timeoutScheduled = Date.now();setTimeout(() =&gt; { const delay = Date.now() - timeoutScheduled; console.log(`${delay}ms have passed since I was scheduled`);}, 100);// 완료하는데 95ms가 걸리는 someAsyncOperation를 실행합니다.someAsyncOperation(() =&gt; { const startCallback = Date.now(); // 10ms가 걸릴 어떤 작업을 합니다. while (Date.now() - startCallback &lt; 10) { // 아무것도 하지 않습니다. }}); 위 예제에서 someAsyncOperation은 함수 자체로 파일 I/O 동작을 가지며 비동기로 95ms가 걸린다고 가정 + 콜백 함수를 받으며 I/O 작업 완료 시 콜백을 호출함 실제 100ms를 지정한 타이머 콜백이 있음 하단에 실제 someAsyncOperation 함수를 호출 위 예제에서 타이머 콜백은 100ms를 지정했음 실제 동작을 보면 일단 전체적으로 코드가 해석되면서 setTimeout이 timer 단계에 걸려있게 됨 someAsyncOperation이 실행되고 fs가 poll 단계에 등록됨 루프가 반복을 돌면서 큐를 확인 먼저 timer 단계에서 걸려있는 100ms가 지나지 않았으므로 다음 단계로 쭉 이동 poll 단계에서 fs 작업이 안끝났음 -&gt; 빈큐를 만나면 가장 빠른 타이머의 임계 값에 도달할 때까지 수 밀리초 대기 -&gt; 대기하는 동안 fs가 종료되고 fs에 넘겼던 콜백이 poll큐에 등록됨 -&gt; fs에 넘겼던 콜백이 실행되고 10ms 동안 실행됨 poll 큐에 작업이 없으므로 루프는 쭉 돌아서 다시 timer로 이동 이때 setTimeout에 지정한 100ms가 지났으므로 콜백이 실행됨 setTimeout에 100ms를 지정해뒀지만 실제로는 루프를 돌면서 각 작업이 실행되며 fs 작업 + fs 콜백의 시간 95ms + 10ms로 105ms가 지난 후에 실행됨 poll 단계가 이벤트 루프를 모두 차지하지 않게 하기 위해 libuv가 추가적인 이벤트를 폴링하는 것에 제한 횟수를 가진다. Pending 콜백 TCP 오류 같은 시스템 작업의 콜백을 실행 예를 들어 TCP 소켓이 연결에 오류가 발생하면 시스템에서 오류를 보고하려고함 -&gt; 이를 실행하기 위해 pending 큐에 추가함 poll poll 단계는 두 가지 주요 기능 I/O를 위해 얼마나 차단하고 poll해야 하는지 계산한다. poll 큐에 있는 이벤트를 수행한다. 만약 루프가 poll단계에 진입했을 때 설정된 타이머가 없다면 다음과 같은 일이 발생한다. poll 큐가 비어있지 않다면, 이벤트 루프는 큐를 돌며 큐의 콜백을 동기적으로 실행한다. 큐가 비거나 시스템이 지정한 제한 수까지 실행한다. poll 큐가 비어있다면 두 가지 중 하나가 발생한다. 만약 스크립트가 setImmediate()로 스케줄 되어 있다면 이벤트 루프는 poll 페이즈를 벗어나 check 페이즈로 이동해 해당 스크립트를 실행한다. 만약 스크립트가 setImmediate()로 스케줄 되어 있지 않다면, 이벤트 루프는 콜백이 큐에 추가되는 것을 기다리고 큐에 추가되면 바로 실행한다. poll 큐가 비게 되면 이벤트 루프는 만료된 타이머를 체크한다. 만약 하나 이상의 타이머가 준비됐다면 이벤트루프는 만료된 타이머를 실행하기 위해 timer 단계로 돌아간다. check 사용자는 check 단계에서 poll 단계가 완료된 이후 콜백을 즉시 실행할 수 있다. 만약 poll 단계가 유휴 상태가 되고 스크립트가 setImmediate()로 큐에 들어오면, 이벤트 루프는 대기하지 않고 check 단계로 이동한다. setImmediate() 는 이벤트 루프의 나눠진 단계에서 실행되는 특별한 타이머이다. libuv API를 사용해 poll 페이즈가 완료됐을 때 실행할 콜백을 스케줄하는 타이머이다. 일반적으로 코드가 실행되면 이벤트 루프는 poll 단계로 이동하고, 들어오는 연결, 요청등을 대기한다. 하지만 만약 setImmediate()로 콜백이 스케줄되고 poll phase가 유휴 상태이면 poll 이벤트를 대기하지 않고 check 단계로 이동한다. close 만약 소켓이나 핸들이 갑자기 종료되는 경우, close 이벤트가 발생한다. 정상 종료된다면 process.nextTick으로 실행된다. setImmediate vs setTimeout setImmediate는 현재 poll 단계가 완료되면 즉 check 단계에서 스크립트를 실행하도록 설계되었음 setTimeout는 최소 임계값이 지난 후 스크립트가 실행되도록 스케줄링 타이머가 실행되는 순서는 어떤 컨텍스트에서 호출되었는지에 따라 다양하다. 둘 다 메인 모듈에서 실행된다면 프로세서의 성능에 따라 달라진다. I/O 주기 내에 있지 않은 컨텍스트에서 두 타이머가 실행된다면 결정적이지 않음 = 순서가 실행 시마다 다름setTimeout(() =&gt; { console.log(\"timeout\");}, 0);setImmediate(() =&gt; { console.log(\"immediate\");});$ node timeout_vs_immediate.jstimeoutimmediate$ node timeout_vs_immediate.jsimmediatetimeout 만약 I/O 주기 내에서 둘을 호출하면 immediate 콜백이 항상 먼저 실행됨// timeout_vs_immediate.jsconst fs = require(\"fs\");fs.readFile(__filename, () =&gt; { setTimeout(() =&gt; { console.log(\"timeout\"); }, 0); setImmediate(() =&gt; { console.log(\"immediate\"); });});$ node timeout_vs_immediate.jsimmediatetimeout$ node timeout_vs_immediate.jsimmediatetimeout setImmediate의 장점은 다른 타이머와 상관 없이 I/O 내에서 스케줄된 어떤 타이머보다 항상 먼저 실행된다.process.nextTick() 페이즈에서 다른 페이즈로 넘어가는 과정을 Tick이라고 부른다. 비동기 API 이벤트 루프의 일부가 아님 nextTickQueue는 이벤트 루프의 현재 단계와 관계없이 현재 작업이 완료된 후에 처리된다. C/C++ 핸들러에서 전환하는 것과 실행되어야하는 javascript를 처리하는 것을 완료한 후 nextTick을 처리함 process.nextTick에 전달한 모든 콜백은 이벤트 루프를 계속 진행하기 전에 처리된다. = 다음 단계로 이동 전에 처리됨 만약 재귀로 process.nextTick()을 호출하면 이벤트 루프가 poll 단계로 이동하는 것을 막아서 I/O가 굶주리게 될 수 있다. process.nextTick 동작을 허용하는 이유 API가 비동기일 필요가 없다라도 비동기여야 한다는 설계 철학 때문 function apiCall(arg, callback) { if (typeof arg !== \"string\") return process.nextTick( callback, new TypeError(\"argument should be string\") );} 위 코드는 제대로된 인자가 아니면 콜백에 에러를 전달 nextTick은 콜백 이후에 작성한 인자를 콜백의 인자로 전달 process.nextTick을 이용하면 apiCall은 항상 유저의 나머지 코드를 실행한 이후 또는 이벤트 루프가 다음 단계로 이동하기 전에 항상 콜백을 실행할 수 있게 보장 이것을 보장하기 위해 JS 콜스택을 unwind를 허용하고, 즉시 제공된 콜백을 실행한다. 이것은 process.nextTick은 콜스택 사이즈 초과를 피하며 재귀 호출을 가능하게 한다. 비동기 철학은 잠재적인 오류를 발생하는 상황을 만들 수 있다. let bar;// this has an asynchronous signature, but calls callback synchronouslyfunction someAsyncApiCall(callback) { callback();}// the callback is called before `someAsyncApiCall` completes.someAsyncApiCall(() =&gt; { // since someAsyncApiCall hasn't completed, bar hasn't been assigned any value console.log(\"bar\", bar); // undefined});bar = 1; 위 코드에서 someAsyncApiCall은 비동기 처럼 콜백을 사용해서 작성한 것 처럼 보이지만 실제론 동기 코드이다. 동기 코드이기 때문에 bar가 선언되기 전에 someAsyncApiCall이 호출되고 동일한 단계에서 인자로 넘긴 콜백 함수가 실행된다. 따라서 bar가 선언되기 전에 콜백함수에서 bar에 접근한다. let bar;function someAsyncApiCall(callback) { process.nextTick(callback);}someAsyncApiCall(() =&gt; { console.log(\"bar\", bar); // 1});bar = 1; 위 동기 코드를 process.nextTick을 사용해 변경한 것이다. 비동기처럼 동작하게 되며 someAsyncApiCall을 실행했을 때 콜백 함수는 nextTick 큐에 들어가 있고 bar가 선언된 이후 현재 단계가 종료되면 다음 단계로 가지 않고 nextTick 큐에 있는 콜백을 실행하게 된다. 이렇게 다른 함수 혹은 값에 접근할 수 있게 되는 이점이 있다. 추가로 에러가 발생한 경우에 이벤트 루프가 다음 단계로 진행하지 않고 에러를 유저에게 알리도록 할 수 있다. const server = net.createServer(() =&gt; {}).listen(8080);server.on(\"listening\", () =&gt; {}); 위 코드는 실제 예제이다. listen(8080) 코드는 포트를 바로 바인딩 한다. 이 경우 listening 콜백을 바로 호출할 수 있게 된다. listening 콜백은 listen 하단에 작성되어 있기 때문에 아직 설정되어 있지 않다. 이것을 피하기 위해 listening 이벤트는 nextTick에 큐에 들어가게 되고, 코드가 모두 실행된 후에 이벤트가 발생하게 된다. 이를 통해 어떤 이벤트 핸들러라도 설정하도록 할 수 있다. process.nextTick vs setImmediate process.nextTick()은 이벤트 루프의 동일한 단계에서 실행됨 setImmediate()는 이어진 반복이나 이벤트 루프의 tick에서 실행됨 두 가지 이름은 서로 반대되야하지만 과거에 설정된 이름으로 바꿀 수 없음 추가로 setImmediate가 예상하기 더 쉬워서 process.nextTick보다는 setImmediate를 권장한다고 함왜 process.nextTick을 사용 사용자가 이벤트 루프가 다음 단계로 이동하기 전에 오류를 처리하고 불필요한 자원을 정리하고 다시 요청을 시도할 수 있게 함 호출 스택은 풀린 뒤에도 이벤트 루프를 계속 진행하기 전에 콜백을 실행해야 하는 경우가 있음정리 이벤트 루프에 대해 공부하면서 각각의 특징과 순서를 이해할 수 있었다. 노드는 자바스크립트 런타임이면서도 웹서버로써의 동작을 위한 로직이 많이 들어가 있는 것 같다. 필요한 경우에 자바스크립트 코드가 실행되며 이벤트 큐 내에서 각각의 동작이 실행되고 또 해당 동작에서 콜백이 실행되고 하는 형태로 필요한 동작들이 연결되서 실행되는 것을 알 수 있었다. 노드는 다른 멀티 스레드 방식과 달리 하나의 스레드를 사용해 요청을 처리하며, I/O에 대한 처리를 비동기로 구현했다. 따라서 I/O 작업이 많고 CPU 작업이 적은 경우에 서버로 선택하기 좋을 것 같다. 대략적인 노드의 동작을 이해해볼 수 있었다. 다만 각 단계에서 발생하는 일을 명확하게는 이해할 수 없었다. 차후에 좀 더 다양한 개발을 해보며 이해해보면 좋을 것 같다.참고Node.js 이벤트 루프, 타이머, process.nextTick - 공식 문서node.js의 이벤트 루프와 libuv의 이해nodejs의 내부 동작 원리로우 레벨로 살펴보는 Node.js 이벤트 루프 - 가장 잘 정리되어 있음" }, { "title": "libuv", "url": "/posts/libuv/", "categories": "노드", "tags": "", "date": "2022-08-15 00:06:00 +0900", "snippet": "Node 공식 문서의 블로킹 vs 논-블로킹 첫 문장이다. I/O는 주로 libuv가 지원하는 시스템 디스크나 네트워크와 상호작용하는 것을 가리킨다.libuv 문서 libuv가 먼저 무엇인지 살펴보자 위 링크를 타고 libuv로 들어가면 Asyncronous I/O made simple - libuv is a multi-platform support library with a focus on asynchronous I/O라는 첫 글이 나온다. Node가 I/O에 대한 처리를 직접하지 않는다는 것이 비동기 I/O 라이브러리인 libuv를 사용함으로써 해결했다는 것을 알 수 있다. document로 들어가보면 어떤 기능을 제공하는지 볼 수 있다. epoll, kqueue, IOCP, event ports를 이용한 event loop 비동기 TCP, UDP 소켓 비동기 DNS resolution 도메인을 ip로 번역 DNS resolution 비동기 파일, 파일 시스템 동작 파일 시스템 이벤트 ETC… Design overview 문서 이벤트 기반 비동기 I/O 모델 I/O polling 메커니즘에 대한 추상화를 제공한다. I/O polling이란 ? 참고 문서 풀링이란 운영체제가 하드웨어 장치의 상태 레지스터를 읽음으로써 명령의 수신 여부를 주기적으로 확인한다 하드웨어 장치의 상태를 수시로 체크하여 명령을 받을 수 있는 상태인지 확인하는 것 ‘handles’, ‘streams’로 소켓과 다른 엔티티들에 대한 높은 레벨의 추상화를 제공한다. 크로스 플랫폼 파일 I/O와 스레딩 기술 또한 제공 Handles &amp; requests libuv는 이벤트 루프를 다루기 위한 2가지 추상화(handle, request)를 제공한다. handles는 long-lived 객체를 나타낸다. 예를 들어 대기 핸들은 활성인 경우 매 루프 반복마다 호출되는 콜백을 받는다. TCP 서버 handle은 연결 콜백을 가지고 있으며 새로운 연결이 생길 때마다 호출된다. handle은 정리해보면 이벤트 루프가 반복될 때 active 상태라면 호출할 콜백을 가지고 있는 객체 request는 short-lived 작업을 나타낸다. 해당 작업은 handle을 통해 수행된다. write request는 핸들에 데이터를 쓰는데 사용된다. getaddrinfo와 같은 요청은 핸들을 통해 실행되지 않고 루프 반복에서 바로 실행된다. 정리해보면 request는 바로 실행되는 독립적인 request와 handle을 통해 실행되는 의존적인 request가 있고, handle을 통해 실행되는 request는 handle을 active 상태로 만들고 handle은 active 상태이므로 콜백을 실행시킨다. 일부 잘못 이해한게 있을 수 있음 I/O loop libuv의 메인 파트 모든 I/O 작업에 대한 컨텐츠를 설정하고, 싱글 스레드에 이를 연결한다. 각각의 이벤트 루프가 다른 스레드에서 실행된다면 여러 개의 이벤트 루프를 실행할 수 있다. libuv의 이벤트 루프는 다른 명시적인 내용이 없다면 thread-safe 하지 않다. thread-safe란 여러 스레드에서 공유 자원에 동시에 접근하더라도 프로그램의 실행에 문제가 없는 경우 = 안전하게 접근할 수 있는 경우 -&gt; ex) 세마포아 같은 락으로 공유자원에 동시 접근을 안전하게 막아놓은 경우 각각의 이벤트 루프는 서로 다른 스레드에서 실행되야 하므로 thread-safe 하지 않으며, 만약 여러개의 이벤트 루프가 실행된다면 동시성에 대한 문제를 해결해야한다. 이벤트 루프는 일반적인 단일 스레드 비동기 I/O 접근 방식을 따른다. 모든 네트워크 I/O는 논 블로킹 소켓에서 수행된다. 논 블로킹 소켓은 각 플랫폼(OS)에서 사용가능한 최고 메커니즘을 사용한다. epoll Linux I/O 통지 모델 - kqueue: OSX, BSDs event ports: SunOS IOCP: Windows 각각의 동작 방식과 소켓에 대한 이해가 필요하므로 일단은 이런 것이 있구나 하고 전체 동작 흐름부터 이해 일단 이벤트 루프 자체는 단일 스레드로 동작하고 네트워크 I/O의 경우 논 블로킹 소켓으로 수행된다. -&gt; I/O는 다시 운영체제의 기능을 사용해 비동기로 처리한다. I/O loop의 동작 출처: libuv 공식 문서 루프의 개념인 now가 업데이트됨, 루프는 시간 관련 시스템 호출 수를 줄이기 위해 이벤트 루프 tick 시작시 현재 시간을 캐시함 간단하게 말하면 반복을 시작할 때 이후 반복 연산에서 시작 관련 호출 수를 줄이기 위해 시간을 저장해둠 루프가 살아있다면 반복 시작, 살아있지 않다면 바로 종료. 루프가 살아있는 경우는 활성 또는 참조되는 handles, 활성된 요청, 종료중인 요청이 있다면 살아있다고 판단됨. 간단하게 말하면 루프에 handle이 참조 또는 활성 상태인 경우, 요청이 활성 상태인 경우, 요청이 종료 중인 경우 루프가 살아있다고 판단하고 반복을 수행, 만약 위와 같은 조건을 만족하지 못하면 바로 종료됨. 만료 타이머 실행. 루프에 캐시된 now 이전으로 시간이 설정된 모든 활성 타이머는 그들의 콜백을 호출. 중지된 콜백 호출. 모든 I/O 콜백은 대부분 I/O에 대한 polling 이후 바로 호출되지만 일부 다음 루프 반복을 위해 중지되는 경우가 있음. 이런 중지된 I/O 콜백들이 여기서 실행됨 I/O 관련 콜백들은 I/O 작업이 끝난 즉 polling 이후 바로 호출됨. 일부 I/O 관련 콜백들은 다음 루프를 위해 중간에 정지되는 경우가 발생함. 이렇게 정지된 경우 여기서 실행됨 Idle 핸들의 콜백을 호출함. Idle 핸들이라는 이름이지만 Idle 핸들이 활성 상태라면 매 루프 반복에서 실행된다. Idle(유휴) 핸들이라는 이름을 가지고 있지만 active(활성)일 때 매 루프에서 항상 실행된다. 준비 핸들이 실행됨. 준비 핸들의 콜백은 I/O를 위해 루프가 중단되기 바로 전에 실행됨 poll 시간 초과가 계산됨. I/O를 위해 루프를 얼마나 차단해야 될지 계산함. 시간 초과를 계산하는 방법은 여러가지가 있음 - 공식 문서 참조 루프는 I/O를 위해 차단됨. 7번 단계에서 계산한 시간만큼 루프가 차단됨. 읽기 또는 쓰기 작업을 위해 파일 디스크립터를 모니터링하던 모든 I/O 관련 handle들은 콜백을 실행한다. 체크 핸들의 콜백들을 호출함. 체크 핸들의 콜백은 루프가 I/O를 위해 차단 됐다가 다시 반복이 시작될 때 호출됨. 준비 핸들의 반대 상황에 실행된다. close 콜백이 호출됨. close 콜백은 handle이 uv_close()를 통해 닫힌 경우 호출된다. 루프가 UV_RUN_ONCE 모드로 실행되고 있는 경우는 반복이 아닌 진행을 의미하며 특수한 경우이다. I/O를 위해 루프를 차단한 후 아무 I/O 콜백이 호출되지 않았을 수 있지만 가끔은 일정 시간이 지남에 따라 만료된 타이머가 있을 수 있으며, 해당 타이머가 콜백을 호출한다. 정확히 이해되진 않지만 UV_RUN_ONCE인 경우 I/O handle을 위해 루프가 차단됐을 때 I/O 콜백이 아무 것도 실행되지 않았지만 루프 차단 해제 후 체크 핸들, close 콜백 실행 즉 9, 10번 작업동안 시간이 지났으므로 종료된 타이머가 있을 수 있으며 종료된 타이머가 콜백을 호출하도록 한다는 의미로 일단 해석했다. 반복 종료. 만약 루프가 UV_RUN_NOWAIT 또는 UV_RUN_ONCE 모드로 실행되면 반복을 돌고 종료되며 uv_run()이 리턴된다. 만약 루프가 UV_RUN_DEFAULT로 실행되면 루프가 살아있다면 다시 반복, 아니라면 종료된다. File I/O 네트워크 I/O와 달리 libuv가 의존할 플랫폼(OS)별 파일 I/O 요소가 없으므로 현재의 접근 방식은 스레드 풀에서 블로킹 I/O 작업을 실행하는 것이다. libuv는 전역 스레드풀을 사용하며, 모든 루프는 작업을 큐에 넣을 수 있다. 3가지 작업이 스레드 풀에서 수행된다. 파일 시스템 작업 DNS uv_queue_work()를 통해 사용자가 명시한 코드 간단 요약모든 코드를 읽으며 이해해보지 않았고 영문을 읽다보니 명확하게 이해되지 않는 부분이 꽤 있다.일단 그래도 요약을 해보자면 libuv는 네트워크, 파일등에 대한 논 블로킹 작업을 수행하게 해준다.각각의 작업은 비동기로 수행되기 때문에 루프가 돌면서 각 단계에서 수행할 수 있는 작업을 수행한다.참고nodejs의 내부 동작 원리Node.js: 비동기 프로그래밍 이해Node.js 동작원리nodejs(express) vs springboot" }, { "title": "블로킹 vs 논-블로킹", "url": "/posts/%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8C%80-%EB%85%BC-%EB%B8%94%EB%A1%9C%ED%82%B9/", "categories": "노드", "tags": "", "date": "2022-08-14 23:39:00 +0900", "snippet": " I/O는 주로 libuv가 지원하는 시스템 디스크나 네트워크와 상호작용하는 것을 가리킨다. libuv 위 링크를 타고 libuv로 들어가면 Asyncronous I/O made simple - libuv is a multi-platform support library with a focus on asynchronous I/O라는 첫 글이 나온다. Node는 I/O를 직접 수행하는 함수가 거의 없다는 것이 libuv를 사용함으로써 비동기로 처리한다는 것을 알 수 있다. libuv에 대한 포스트 : libuv 포스트 블로킹 블로킹은 노드 프로세스가 추가적인 자바스크립트 실행을 위해 자바스크립트가 아닌 작업이 안료될 때까지 기대려야하는 상황을 뜻한다. 이는 이벤트 루프가 블로킹 작업을 하는 동안 자바스크립트 실행을 계속할 수 없기 때문 동기적인 코드 수행이라고 생각하면 될 것 같다. 단일 흐름(스레드)으로 실행된다면 I/O의 응답을 기다리는 동안 다른 작업을 못 하기 때문에 대기해야한다. 노드에서는 많은 연산을 해야하는 CPU 집약적인 자바스크립트 코드 실행을 블로킹이라 부르지 않고 I/O와 같은 자바스크립트가 아닌 작업을 기다리는 것을 블로킹이라 부름. libuv를 사용하는 노드 표준 라이브러리의 동기 메서드가 대표적인 블로킹 작업이며 네이티브 모듈도 블로킹 메서드를 가질 수 있음 노드의 표준 라이브러리의 모든 I/O 메서드는 논블로킹인 비동기 방식을 제공하고 콜백 함수를 받는다. 일부 메서드는 블로킹 메서드도 가지며 마지막에 sync 키워드가 붙는다. 요약: 자바스크립트 코드는 CPU 집약적인(연산이 많은) 코드이더라도 블로킹이라 부르지 않으며 I/O와 같이 자바스크립트가 아닌 수행을 기다리는 것을 블로킹이라 부름. 표준 라이브러리의 I/O 메서드는 비동기이며 동기 방식을 제공하는 경우도 있음 코드 비교아래 코드는 공식 문서의 예시임동기:const fs = require(\"fs\");const data = fs.readFileSync(\"/file.md\"); // 파일을 읽을 때까지 여기서 블로킹됩니다.console.log(data);moreWork(); // console.log 이후 실행될 것입니다.비동기:const fs = require(\"fs\");fs.readFile(\"/file.md\", (err, data) =&gt; { if (err) throw err; console.log(data);});moreWork(); // console.log 이전에 실행될 것입니다.동기의 경우 파일 작업을 대기하고 이후에 console, moreWork가 실행됨비동기의 경우 파일 작업을 요청해놓고 이후 자바스크립트 코드를 실행 - moreWork가 console보다 먼저 실행됨동시성과 스루풋 노드에서 자바스크립트 실행이 싱글스레드 - 노드 전체가 싱글 스레드가 아님 동시성은 다른 작업이 완료된 후 자바스크립트 콜백 함수를 실행하는 이벤트 루프의 능력을 의미 I/O 작업과 같이 동시에 실행돼야 한다고 예상되는 자바스크립트가 아닌 코드들은 이벤트 루프가 계속 실행될 수 있도록 보장해야한다. - 간단하게는 자바스크립트가 아니라면 자바스크립트 작업을 막아서는 안된다. 예를 들어 각 요청 완료까지 50ms가 걸리고 45ms는 비동기 DB I/O인 상황이라면 논 블로킹으로 작업하면 5초의 자바스크립트 작업 후 45ms는 다른 요청을 처리할 수 있다. 이벤트 루프는 동시 작업을 다루려고 부가적인 스레드를 만드는 다른 언어의 모델과는 다르다. 각 스레드가 요청을 처리하지 않고 단일 스레드가 요청을 확인하고 동작을 수행하는 대신 자바스크립트가 아닌 동작을 비동기로 처리 - libuv로 비동기 처리 - 네트워크는 커널에 비동기로 요청, 파일은 다른 스레드에서 작업함" }, { "title": "Nodejs", "url": "/posts/nodejs/", "categories": "노드", "tags": "", "date": "2022-08-14 21:02:00 +0900", "snippet": "노드는 자바스크립트를 언어로 사용한다면 클라이언트, 서버 어디서든 사용 된다. 먼저 Node가 무엇인지 작성해보면 좋을 것 같아 공식 문서를 보며 작성해보려 한다.공식문서Nodejs란 비동기 이벤트 주도 자바스크립트 런타임 비동기: 일정 단위 코드의 실행을 메인 흐름에서 기다리지 않는 것을 보통 비동기라고 표현 예를 들어 어떤 변수 a에 단순한 값이 아닌 계산된 값을 할당하는 경우, 동기로 a에 계산된 값을 할당하면 할당 이후의 모든 코드에서 a에 접근하면 계산된 값을 얻을 수 있다. 반면에 비동기로 a에 계산된 값을 할당한다면 값의 계산은 메인 흐름에서 벗어나 계산되고 이후의 모든 코드에서 계산된 값을 얻을 수 있다는 것을 보장할 수 없다. //동기 코드let a = 0;a = 3 + 1;const b = a;const c = a;console.log(a, b, c);//비동기 코드const exam = () =&gt; { let a = 0; setTimeout(() =&gt; { a = 3 + 1; console.log(a, b, c); }, 3000); const b = a; const c = a; console.log(a, b, c);};exam();//결과//4,4,4//0,0,0//4,0,0 이벤트 주도: 이벤트 발생에 따라 어떤 로직을 처리함 Event-Driven-Architecture 다른 블로그에 잘 설명되어 있어 링크함 좋은 설명 링크 OS 스레드가 일반적으로 사용하는 동시성 모델과는 대조적입니다. 스레드 기반의 네트워크는 상대적으로 비효율적이고 사용하기가 몹시 어렵습니다. 게다가 잠금이 없으므로 Node.js 의 사용자는 프로세스의 교착상태에 대해서 걱정할 필요가 없습니다. 프로세스는 프로그램이 실행된 인스턴스라고 생각하면 된다. 프로세스는 OS에서 자원을 할당받는 작업의 단위이다. 각 프로세스는 독립적인 시스템 자원을 할당받는다. 할당받는 시스템 자원은 CPU 시간, 실행에 필요한 주소 공간, 메모리 등이 있다. 스레드는 프로세스내에서 실행되는 여러 흐름의 단위이다. 여러 스레드는 프로세스가 할당받은 OS 자원을 공유해서 사용한다. 동시성이란 동시에 실행되는 것처럼 보이는 것이다. 스레드 동시성은 여러 스레드가 동시에 실행되는 것 처럼 보이며 공유하는 자원 중에 동일한 자원을 놓고 경쟁할 수 있다. -&gt; 서로 사용하려함 보통 이런 경우 두 스레드가 동일한 자원에 접근하려면 정해둔 규칙에 따라 사용하게 되는 스레드 쪽에서 락을 걸어 다른 스레드가 접근할 수 없게 막아둔다. 잠금이 없다는 것은 여러 스레드가 동시에 동일한 자원에 접근할 일이 없어 락을 걸지 않아도 된다는 것이다. 교착 상태란 두 스레드가 A,B라는 자원이 필요한 경우 한 스레드는 A 자원에 락을 걸고 다른 스레드는 B 자원에 락을 걸고 서로의 자원이 락이 해제되기를 무한히 기다리게 되는 상태를 말한다. 락이 없기 때문에 교착 상태를 고려하지 않아도 된다는 뜻이다. Node.js 에서 I/O를 직접 수행하는 함수는 거의 없으므로 프로세스는 결과 블로킹 되지 않습니다. 아무것도 블로킹 되지 않으므로 Node.js 에서는 확장성 있는 시스템을 개발하는 게 아주 자연스럽습니다. I/O를 직접 수행하지 않는다 -&gt; 비동기로 던져놓는다고 해석 블로킹 되지 않는다 -&gt; I/O의 결과가 오면 처리할 뿐 처리를 대기하지 않는다. 첫줄의 비동기 이벤트 주도를 아래의 공식 문서의 예제 코드로 이해해보면 요청이 올 때까지가 Nodejs는 대기 요청이 오면 이벤트 발생 이벤트에 따른 로직 처리 I/O 작업이 필요하다면 비동기로 처리 그 사이 다른 요청이 오면 해당 요청 처리 비동기 끝나면 응답 전송 노드는 이벤트 루프를 라이브러리가 아닌 런타임 생성자로 제공 다른 시스템과 달리 이벤트 루프를 시작하는 블럭킹 호출이 없음 노드는 입력 스크립트를 실행한 후 이벤트 루프에 바로 진입함. 더 이상 실행할 콜백이 없다면 노드는 이벤트 루프를 종료함 노드는 HTTP를 일급 객체로 다룸. 노드는 스레드를 사용하지 않도록 설계되었지만 멀티 코어의 장점을 얻지 못한다는 것은 아님 child_process.fork()를 사용해 자식 프로세스를 생성할 수 있음 사담 스레드 동시성 모델으로 동작하는 서버로 자바 + 스프링이 있는 것으로 알고 있다. 두 조합을 사용해보지 않아서 추상적으로 비동기 + 이벤트 주도가 I/O 블럭킹이 없고 스레드를 직접 다루지 않아도 되서 락과 교착상태에 대한 걱정이 없다는 장점을 이론적으로만 이해할 수 있었다. 자프링을 공부해보고 비교할 기회가 있다면 좋을 것 같다. 블로킹대 논 블로킹을 읽어보고 여러 블로그의 글도 읽어본 결과 요청에 대한 처리에 I/O 접근이 많고, CPU 연산이 많이 필요하지 않다면 단일 스레드로 자바스크립트를 실행하고 I/O를 비동기로 던지는 노드를 선택하는 것이 좋고, CPU 연산이 꽤 필요하다면 자바 + 스프링 같은 멀티스레드 프레임워크로 스레드를 나눠서 처리하는 쪽을 선택하는 것이 좋을 것 같다. 추가적으로 스프링을 잠깐 공부해보고 알게된 내용인데 스프링은 웹서버인 톰캣을 내장해서 요청과 응답을 처리한다면 노드는 자체적으로 웹서버 역할을 수행할 수 있다. 따라서 노드는 어떻게 보면 자바스크립트 런타임이자 웹서버인 느낌이다.참고 자료[Java] 멀티 스레드환경의 동시성 이슈 그리고 해결방법[OS] 스레드와 동시성(Thread &amp; Concurrency) - 자세함추가 스프링과 비교" }, { "title": "블로그 시작", "url": "/posts/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%8B%9C%EC%9E%91/", "categories": "잡담", "tags": "", "date": "2022-08-14 20:21:00 +0900", "snippet": "블로그를 시작하며…개발 공부를 시작한 이후 github, 블로그를 하는 것이 좋다는 말을 들었다. github의 경우 코드를 올리는 것이기에 반감이 들지 않았아 바로 사용했다. 블로그의 경우엔 공부 내용을 올리기엔 책이나 강의 내용을 조금 바꾸어 올리게 될 것 같았고 무엇보다 글을 잘 쓸 자신이 없어 시작하지 않았다.최근 한 가지 일을 계기로 왜 블로그를 운영하는 것이 좋다고 했는지를 조금은 체험할 수 있었다. 면접이 끝냈을 때의 감정은 절망 그 자체였다. 처음 웹 개발 공부를 시작할 때 어떤 방식으로 접근해야 할까 많은 고민을 했고, 그중 가장 크게 고민했던 것은 아키텍처나 코드를 보고 전체적인 흐름이 와닿지 않는다는 것이었다. 어쨋든 일단 부딪혀 봐야겠다는 결정을 했고, 실제 둘 다 코드를 작성해보며 나름 중간 중간 이런 저런 고민도 해보고 해결법도 찾아서 해결해봤다. 이렇게 해보고나니 나름 이해도가 생겼고 어느정도 간단한 일은 할 수 있다는 생각이 들어 회사에 지원을 해봤다. 운이 좋게 면접 기회를 얻게 되었고 1시간의 코테와 기술 면접을 경험할 수 있었다. 코테는 IDE 없이 작성하다 보니 당황스러웠지만 이리저리 실행해보며 IDE 없이 문제를 해결하는 방법을 차차 터득해 풀어 나갈 수는 있었다. 문제는 기술 면접이였다. Node, REST 등 서버에 관련된 질문과 자료구조, 알고리즘에 대한 질문을 받았다. 여기서 큰 절망을 느낄 수 있었다. 그 동안 아 ~ 이렇게 동작하는구나를 그냥 읽고 대충 정리하면서 공부했었다. 혼자 개발할 때는 이런 방식으로 공부해도 기억나지 않는 건 다시 찾아보며 진행할 수 있었지만 면접에선 어떤 키워드를 기준으로 해당 키워드와 관련된 또 다른 키워드들에 대한 질문을 던지며 답변을 요구하다보니 추상적인 대답 밖에 할 수 없었다. 특히 꼬리 질문에선 각 키워드들의 연결점을 찾아내지 못 했고 뒤로 갈 수록 모르겠다는 말 밖에 할 수 없었다. 가장 기억에 남는 질문은 다익스트라 알고리즘에 대한 질문이었다. 알고리즘, 네트워크 수업에서 여러번 구현해봤고, 알고리즘 풀이 사이트들에서 사용한 경우도 있었기 때문에 당연히 답할 수 있는 질문이었다. 그런데 막상 설명해보라고 하니 머리엔 아무것도 생각나지 않았고 아무말도 할 수 없었다. 여튼 이번 면접 경험이 모르는게 많다는 것을 알게 해줬고 아는 것도 제대로 말할 수 없다는 것을 깨닳게 해주는 좋은 기회였다고 생각한다.위와 같은 경험을 하고나니 최소한 내가 공부했던 내용을 머리에 흩뿌려서 기억하지 말고 글로써 정리라도 해봐야겠다는 생각이 들었다. 앞으로 차근차근 공부한 내용을 정리할 수 있다면 정리해서 블로그에 올려보려고 한다." } ]
