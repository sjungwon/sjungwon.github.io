<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="이벤트루프" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="이벤트 루프란?" /><meta property="og:description" content="이벤트 루프란?" /><link rel="canonical" href="/posts/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%84/" /><meta property="og:url" content="/posts/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%84/" /><meta property="og:site_name" content="코드정원" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-08-17T02:36:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="이벤트루프" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-08-17T02:36:00+09:00","datePublished":"2022-08-17T02:36:00+09:00","description":"이벤트 루프란?","headline":"이벤트루프","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%84/"},"url":"/posts/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%84/"}</script><title>이벤트루프 | 코드정원</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="코드정원"><meta name="application-name" content="코드정원"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">코드정원</a></div><div class="site-subtitle font-italic">개발 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sjungwon" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['gardenson03','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 홈 </a> </span> <span>이벤트루프</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>이벤트루프</h1><div class="post-meta text-muted"> <span> 게시 <em class="" data-ts="1660671360" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-08-17 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/username">sjungwon</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4025 단어"> <em>22 분</em>읽는 시간</span></div></div></div><div class="post-content"><h3 id="이벤트-루프란"><span class="mr-2">이벤트 루프란?</span><a href="#이벤트-루프란" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>노드가 논 블로킹 I/O 작업을 수행할 수 있도록 이벤트 루프가 비동기가 가능하면 시스템 커널에 작업을 넘김<li>현대 커널은 멀티 스레드이므로 백그라운드에서 다수의 작업을 실행 가능<li>커널에서 작업을 완료하면 커널이 노드에게 완료를 알려주어 적잘한 콜백을 poll 큐에 추가할 수 있게함</ul><h3 id="설명"><span class="mr-2">설명</span><a href="#설명" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>노드를 시작할 때 이벤트 루프를 초기화하고 제공된 입력 스크립트를 처리<li>입력 스크립트에서는 비동기 API, 타이머, process.nextTick()을 호출 가능<li>이후 이벤트루프 처리를 시작함</ul><h3 id="이벤트-루프-단계"><span class="mr-2">이벤트 루프 단계</span><a href="#이벤트-루프-단계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>   ┌───────────────────────────┐
┌─&gt;│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │&lt;─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
</pre></table></code></div></div><ul><li><p>공식 문서의 다이어그램</p><li>노드는 libuv의 이벤트 루프를 사용한다, 각 단계를 libuv와 비교해보면<ul><li>libuv 루프 시작 -&gt; 만료된 타이머 콜백 실행 -&gt; pending handles -&gt; idle handles -&gt; prepare handles -&gt; poll for I/O -&gt; check handles -&gt; close callbacks -&gt; 반복<li>위 다이어 그램과 동일하다는 것을 알 수 있다.</ul><li>각 단계는 실행할 콜백의 FIFO 큐를 가진다.<li>각 단계는 자신만의 방법에 제한적으로 이벤트 루프가 해당 단계에 진입하면 해당 단계에 한정된 작업을 수행<li>각 단계의 큐를 모두 소진하거나, 콜백의 최대 개수를 실행할 때까지 해당 단계의 큐에서 콜백을 실행.<li>큐를 모두 소진 혹은 최대 개수에 이르면 이벤트 루프는 다음 단계로 이동<li>각 작업이 또 다른 작업을 스케줄링하거나, poll 단계에서 처리된 새로운 이벤트가 커널에 의해 큐에 추가될 수 있으므로 폴링 이벤트를 처리하면서 poll 이벤트를 큐에 추가할 수 있다. 그 결과로 오래 실행되는 콜백은 poll 단계가 타이머 한계 시점보다 훨씬 더 오래 실행되도록 할 수 있다.<ul><li>libuv에서 poll 단계에 들어가기 전에 poll에서 사용할 시간을 설정함, 이후 poll에서 설정한 시간동안 루프가 멈추게 되는데 아마 이를 또 설정할 수 있는 듯</ul></ul><h3 id="각-단계-개요"><span class="mr-2">각 단계 개요</span><a href="#각-단계-개요" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>timers: 이 단계는 setTimeout()과 setInterval()로 스케줄링한 콜백을 실행합니다.<li>pending callbacks: 다음 루프 반복으로 연기된 I/O 콜백들을 실행합니다.<li>idle, prepare: 내부용으로만 사용합니다.<li>poll: 새로운 I/O 이벤트를 가져옵니다. I/O와 연관된 콜백(클로즈 콜백, 타이머로 스케줄링된 콜백, setImmediate()를 제외한 거의 모든 콜백)을 실행합니다. 적절한 시기에 node는 여기서 블록 합니다.<li>check: setImmediate() 콜백은 여기서 호출됩니다.<li>close callbacks: 일부 close 콜백들, 예를 들어 socket.on(‘close’, …).</ul><h3 id="각-단계-세부-내용"><span class="mr-2">각 단계 세부 내용</span><a href="#각-단계-세부-내용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>timers</p><ul><li>타이머는 사람이 실행하기를 원하는 정확한 시간이 아닌 제공된 콜백이 일정 시간 후에 실행되어야 하는 기준 시간을 지정<li>타이머 콜백은 지정한 시간이 지난 후에 스케줄링 될 수 있는 가장 이른 시간에 실행됨<li>운영체제 스케줄링이나 다른 콜백 실행 때문에 지연될 수 있음<li>아래는 공식 문서의 예시</ul><div class="language-javascript highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">fs</span><span class="dl">"</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">someAsyncOperation</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 이 작업이 완료되는데 95ms가 걸린다고 가정합니다.</span>
  <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="dl">"</span><span class="s2">/path/to/file</span><span class="dl">"</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">timeoutScheduled</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>

<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">delay</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span> <span class="o">-</span> <span class="nx">timeoutScheduled</span><span class="p">;</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">delay</span><span class="p">}</span><span class="s2">ms have passed since I was scheduled`</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">100</span><span class="p">);</span>

<span class="c1">// 완료하는데 95ms가 걸리는 someAsyncOperation를 실행합니다.</span>
<span class="nx">someAsyncOperation</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">startCallback</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>

  <span class="c1">// 10ms가 걸릴 어떤 작업을 합니다.</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span> <span class="o">-</span> <span class="nx">startCallback</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 아무것도 하지 않습니다.</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></table></code></div></div><ul><li>위 예제에서 someAsyncOperation은 함수 자체로 파일 I/O 동작을 가지며 비동기로 95ms가 걸린다고 가정 + 콜백 함수를 받으며 I/O 작업 완료 시 콜백을 호출함<li>실제 100ms를 지정한 타이머 콜백이 있음<li>하단에 실제 someAsyncOperation 함수를 호출<li>위 예제에서 타이머 콜백은 100ms를 지정했음<li>실제 동작을 보면 일단 전체적으로 코드가 해석되면서 setTimeout이 timer 단계에 걸려있게 됨<li>someAsyncOperation이 실행되고 fs가 poll 단계에 등록됨<li>루프가 반복을 돌면서 큐를 확인<li>먼저 timer 단계에서 걸려있는 100ms가 지나지 않았으므로 다음 단계로 쭉 이동<li>poll 단계에서 fs 작업이 안끝났음 -&gt; 빈큐를 만나면 가장 빠른 타이머의 임계 값에 도달할 때까지 수 밀리초 대기 -&gt; 대기하는 동안 fs가 종료되고 fs에 넘겼던 콜백이 poll큐에 등록됨 -&gt; fs에 넘겼던 콜백이 실행되고 10ms 동안 실행됨<li>poll 큐에 작업이 없으므로 루프는 쭉 돌아서 다시 timer로 이동<li>이때 setTimeout에 지정한 100ms가 지났으므로 콜백이 실행됨<li>setTimeout에 100ms를 지정해뒀지만 실제로는 루프를 돌면서 각 작업이 실행되며 fs 작업 + fs 콜백의 시간 95ms + 10ms로 105ms가 지난 후에 실행됨<li>poll 단계가 이벤트 루프를 모두 차지하지 않게 하기 위해 libuv가 추가적인 이벤트를 폴링하는 것에 제한 횟수를 가진다.</ul><li><p>Pending 콜백</p><ul><li>TCP 오류 같은 시스템 작업의 콜백을 실행<li>예를 들어 TCP 소켓이 연결에 오류가 발생하면 시스템에서 오류를 보고하려고함 -&gt; 이를 실행하기 위해 pending 큐에 추가함</ul><li>poll<ul><li>poll 단계는 두 가지 주요 기능<ol><li>I/O를 위해 얼마나 차단하고 poll해야 하는지 계산한다.<li>poll 큐에 있는 이벤트를 수행한다.</ol><li>만약 루프가 poll단계에 진입했을 때 설정된 타이머가 없다면 다음과 같은 일이 발생한다.<ul><li>poll 큐가 비어있지 않다면, 이벤트 루프는 큐를 돌며 큐의 콜백을 동기적으로 실행한다. 큐가 비거나 시스템이 지정한 제한 수까지 실행한다.<li>poll 큐가 비어있다면 두 가지 중 하나가 발생한다.<ul><li>만약 스크립트가 setImmediate()로 스케줄 되어 있다면 이벤트 루프는 poll 페이즈를 벗어나 check 페이즈로 이동해 해당 스크립트를 실행한다.<li>만약 스크립트가 setImmediate()로 스케줄 되어 있지 않다면, 이벤트 루프는 콜백이 큐에 추가되는 것을 기다리고 큐에 추가되면 바로 실행한다.</ul><li>poll 큐가 비게 되면 이벤트 루프는 만료된 타이머를 체크한다. 만약 하나 이상의 타이머가 준비됐다면 이벤트루프는 만료된 타이머를 실행하기 위해 timer 단계로 돌아간다.</ul></ul><li>check<ul><li>사용자는 check 단계에서 poll 단계가 완료된 이후 콜백을 즉시 실행할 수 있다. 만약 poll 단계가 유휴 상태가 되고 스크립트가 setImmediate()로 큐에 들어오면, 이벤트 루프는 대기하지 않고 check 단계로 이동한다.<li>setImmediate() 는 이벤트 루프의 나눠진 단계에서 실행되는 특별한 타이머이다. libuv API를 사용해 poll 페이즈가 완료됐을 때 실행할 콜백을 스케줄하는 타이머이다.<li>일반적으로 코드가 실행되면 이벤트 루프는 poll 단계로 이동하고, 들어오는 연결, 요청등을 대기한다. 하지만 만약 setImmediate()로 콜백이 스케줄되고 poll phase가 유휴 상태이면 poll 이벤트를 대기하지 않고 check 단계로 이동한다.</ul><li>close<ul><li>만약 소켓이나 핸들이 갑자기 종료되는 경우, close 이벤트가 발생한다. 정상 종료된다면 process.nextTick으로 실행된다.</ul></ul><h3 id="setimmediate-vs-settimeout"><span class="mr-2">setImmediate vs setTimeout</span><a href="#setimmediate-vs-settimeout" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>setImmediate는 현재 poll 단계가 완료되면 즉 check 단계에서 스크립트를 실행하도록 설계되었음<li>setTimeout는 최소 임계값이 지난 후 스크립트가 실행되도록 스케줄링<li>타이머가 실행되는 순서는 어떤 컨텍스트에서 호출되었는지에 따라 다양하다. 둘 다 메인 모듈에서 실행된다면 프로세서의 성능에 따라 달라진다. I/O 주기 내에 있지 않은 컨텍스트에서 두 타이머가 실행된다면 결정적이지 않음 = 순서가 실행 시마다 다름</ul><div class="language-javascript highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">timeout</span><span class="dl">"</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

<span class="nx">setImmediate</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">immediate</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>
</pre></table></code></div></div><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nv">$ </span>node timeout_vs_immediate.js
<span class="nb">timeout
</span>immediate

<span class="nv">$ </span>node timeout_vs_immediate.js
immediate
<span class="nb">timeout</span>
</pre></table></code></div></div><ul><li>만약 I/O 주기 내에서 둘을 호출하면 immediate 콜백이 항상 먼저 실행됨</ul><div class="language-javascript highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">// timeout_vs_immediate.js</span>
<span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">fs</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">__filename</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">timeout</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
  <span class="nx">setImmediate</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">immediate</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></table></code></div></div><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nv">$ </span>node timeout_vs_immediate.js
immediate
<span class="nb">timeout</span>

<span class="nv">$ </span>node timeout_vs_immediate.js
immediate
<span class="nb">timeout</span>
</pre></table></code></div></div><ul><li>setImmediate의 장점은 다른 타이머와 상관 없이 I/O 내에서 스케줄된 어떤 타이머보다 항상 먼저 실행된다.</ul><h3 id="processnexttick"><span class="mr-2">process.nextTick()</span><a href="#processnexttick" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>페이즈에서 다른 페이즈로 넘어가는 과정을 Tick이라고 부른다.</p><li>비동기 API<li>이벤트 루프의 일부가 아님<li>nextTickQueue는 이벤트 루프의 현재 단계와 관계없이 현재 작업이 완료된 후에 처리된다.<li>C/C++ 핸들러에서 전환하는 것과 실행되어야하는 javascript를 처리하는 것을 완료한 후 nextTick을 처리함<li>process.nextTick에 전달한 모든 콜백은 이벤트 루프를 계속 진행하기 전에 처리된다. = 다음 단계로 이동 전에 처리됨<li>만약 재귀로 process.nextTick()을 호출하면 이벤트 루프가 poll 단계로 이동하는 것을 막아서 I/O가 굶주리게 될 수 있다.<li><p>process.nextTick 동작을 허용하는 이유</p><ul><li>API가 비동기일 필요가 없다라도 비동기여야 한다는 설계 철학 때문</ul><div class="language-javascript highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">apiCall</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">arg</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(</span>
      <span class="nx">callback</span><span class="p">,</span>
      <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="dl">"</span><span class="s2">argument should be string</span><span class="dl">"</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>위 코드는 제대로된 인자가 아니면 콜백에 에러를 전달<li>nextTick은 콜백 이후에 작성한 인자를 콜백의 인자로 전달<li>process.nextTick을 이용하면 apiCall은 항상 유저의 나머지 코드를 실행한 이후 또는 이벤트 루프가 다음 단계로 이동하기 전에 항상 콜백을 실행할 수 있게 보장<li>이것을 보장하기 위해 JS 콜스택을 unwind를 허용하고, 즉시 제공된 콜백을 실행한다.<li><p>이것은 process.nextTick은 콜스택 사이즈 초과를 피하며 재귀 호출을 가능하게 한다.</p><li>비동기 철학은 잠재적인 오류를 발생하는 상황을 만들 수 있다.</ul><div class="language-javascript highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">bar</span><span class="p">;</span>

<span class="c1">// this has an asynchronous signature, but calls callback synchronously</span>
<span class="kd">function</span> <span class="nx">someAsyncApiCall</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">callback</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// the callback is called before `someAsyncApiCall` completes.</span>
<span class="nx">someAsyncApiCall</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// since someAsyncApiCall hasn't completed, bar hasn't been assigned any value</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">,</span> <span class="nx">bar</span><span class="p">);</span> <span class="c1">// undefined</span>
<span class="p">});</span>

<span class="nx">bar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>위 코드에서 someAsyncApiCall은 비동기 처럼 콜백을 사용해서 작성한 것 처럼 보이지만 실제론 동기 코드이다. 동기 코드이기 때문에 bar가 선언되기 전에 someAsyncApiCall이 호출되고 동일한 단계에서 인자로 넘긴 콜백 함수가 실행된다. 따라서 bar가 선언되기 전에 콜백함수에서 bar에 접근한다.</ul><div class="language-javascript highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">bar</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">someAsyncApiCall</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">someAsyncApiCall</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">,</span> <span class="nx">bar</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="p">});</span>

<span class="nx">bar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>위 동기 코드를 process.nextTick을 사용해 변경한 것이다.<li>비동기처럼 동작하게 되며 someAsyncApiCall을 실행했을 때 콜백 함수는 nextTick 큐에 들어가 있고 bar가 선언된 이후 현재 단계가 종료되면 다음 단계로 가지 않고 nextTick 큐에 있는 콜백을 실행하게 된다.<li>이렇게 다른 함수 혹은 값에 접근할 수 있게 되는 이점이 있다. 추가로 에러가 발생한 경우에 이벤트 루프가 다음 단계로 진행하지 않고 에러를 유저에게 알리도록 할 수 있다.</ul><div class="language-javascript highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{}).</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span>

<span class="nx">server</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">listening</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{});</span>
</pre></table></code></div></div><ul><li>위 코드는 실제 예제이다.<li>listen(8080) 코드는 포트를 바로 바인딩 한다. 이 경우 listening 콜백을 바로 호출할 수 있게 된다. listening 콜백은 listen 하단에 작성되어 있기 때문에 아직 설정되어 있지 않다.<li>이것을 피하기 위해 listening 이벤트는 nextTick에 큐에 들어가게 되고, 코드가 모두 실행된 후에 이벤트가 발생하게 된다.<li>이를 통해 어떤 이벤트 핸들러라도 설정하도록 할 수 있다.</ul></ul><h3 id="processnexttick-vs-setimmediate"><span class="mr-2">process.nextTick vs setImmediate</span><a href="#processnexttick-vs-setimmediate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>process.nextTick()은 이벤트 루프의 동일한 단계에서 실행됨<li>setImmediate()는 이어진 반복이나 이벤트 루프의 tick에서 실행됨<li>두 가지 이름은 서로 반대되야하지만 과거에 설정된 이름으로 바꿀 수 없음<li>추가로 setImmediate가 예상하기 더 쉬워서 process.nextTick보다는 setImmediate를 권장한다고 함</ul><h3 id="왜-processnexttick을-사용"><span class="mr-2">왜 process.nextTick을 사용</span><a href="#왜-processnexttick을-사용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>사용자가 이벤트 루프가 다음 단계로 이동하기 전에 오류를 처리하고 불필요한 자원을 정리하고 다시 요청을 시도할 수 있게 함<li>호출 스택은 풀린 뒤에도 이벤트 루프를 계속 진행하기 전에 콜백을 실행해야 하는 경우가 있음</ol><h3 id="정리"><span class="mr-2">정리</span><a href="#정리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>이벤트 루프에 대해 공부하면서 각각의 특징과 순서를 이해할 수 있었다.<li>노드는 자바스크립트 런타임이면서도 웹서버로써의 동작을 위한 로직이 많이 들어가 있는 것 같다.<li>필요한 경우에 자바스크립트 코드가 실행되며 이벤트 큐 내에서 각각의 동작이 실행되고 또 해당 동작에서 콜백이 실행되고 하는 형태로 필요한 동작들이 연결되서 실행되는 것을 알 수 있었다.<li>노드는 다른 멀티 스레드 방식과 달리 하나의 스레드를 사용해 요청을 처리하며, I/O에 대한 처리를 비동기로 구현했다. 따라서 I/O 작업이 많고 CPU 작업이 적은 경우에 서버로 선택하기 좋을 것 같다.<li>대략적인 노드의 동작을 이해해볼 수 있었다. 다만 각 단계에서 발생하는 일을 명확하게는 이해할 수 없었다. 차후에 좀 더 다양한 개발을 해보며 이해해보면 좋을 것 같다.</ul><h3 id="참고"><span class="mr-2">참고</span><a href="#참고" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://nodejs.org/ko/docs/guides/event-loop-timers-and-nexttick/">Node.js 이벤트 루프, 타이머, process.nextTick - 공식 문서 </a><br /> <a href="https://blog.naver.com/pjt3591oo/221976414901">node.js의 이벤트 루프와 libuv의 이해</a><br /> <a href="https://sjh836.tistory.com/149">nodejs의 내부 동작 원리</a></p><p><a href="https://evan-moon.github.io/2019/08/01/nodejs-event-loop-workflow/">로우 레벨로 살펴보는 Node.js 이벤트 루프</a> - 가장 잘 정리되어 있음</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%EB%85%B8%EB%93%9C/'>노드</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%84+-+%EC%BD%94%EB%93%9C%EC%A0%95%EC%9B%90&url=%2Fposts%2F%25EC%259D%25B4%25EB%25B2%25A4%25ED%258A%25B8%25EB%25A3%25A8%25ED%2594%2584%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%84+-+%EC%BD%94%EB%93%9C%EC%A0%95%EC%9B%90&u=%2Fposts%2F%25EC%259D%25B4%25EB%25B2%25A4%25ED%258A%25B8%25EB%25A3%25A8%25ED%2594%2584%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2F%25EC%259D%25B4%25EB%25B2%25A4%25ED%258A%25B8%25EB%25A3%25A8%25ED%2594%2584%2F&text=%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%84+-+%EC%BD%94%EB%93%9C%EC%A0%95%EC%9B%90" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/%EC%9E%90%EB%B0%94%EC%96%B8%EC%96%B4%EC%9D%98-%ED%8A%B9%EC%A7%95/">자바 언어의 특징</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/%EA%B0%80%EB%B9%84%EC%A7%80%EC%BB%AC%EB%A0%89%ED%84%B0/">가비지컬렉터</a> <a class="post-tag" href="/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/">디자인패턴</a> <a class="post-tag" href="/tags/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C/">멀티스레드</a> <a class="post-tag" href="/tags/%ED%85%9C%ED%94%8C%EB%A6%BF%EB%A9%94%EC%86%8C%EB%93%9C/">템플릿메소드</a> <a class="post-tag" href="/tags/%ED%9B%85/">훅</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/nodejs/"><div class="card-body"> <em class="small" data-ts="1660478520" data-df="YYYY-MM-DD" > 2022-08-14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Nodejs</h3><div class="text-muted small"><p> 노드는 자바스크립트를 언어로 사용한다면 클라이언트, 서버 어디서든 사용 된다. 먼저 Node가 무엇인지 작성해보면 좋을 것 같아 공식 문서를 보며 작성해보려 한다. 공식문서 Nodejs란 비동기 이벤트 주도 자바스크립트 런타임 비동기: 일정 단위 코드의 실행을 메인 흐름에서 기다리지 않는 것을 보통 비동기라고 ...</p></div></div></a></div><div class="card"> <a href="/posts/%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8C%80-%EB%85%BC-%EB%B8%94%EB%A1%9C%ED%82%B9/"><div class="card-body"> <em class="small" data-ts="1660487940" data-df="YYYY-MM-DD" > 2022-08-14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>블로킹 vs 논-블로킹</h3><div class="text-muted small"><p> I/O는 주로 libuv가 지원하는 시스템 디스크나 네트워크와 상호작용하는 것을 가리킨다. libuv 위 링크를 타고 libuv로 들어가면 Asyncronous I/O made simple - libuv is a multi-platform support library with ...</p></div></div></a></div><div class="card"> <a href="/posts/libuv/"><div class="card-body"> <em class="small" data-ts="1660489560" data-df="YYYY-MM-DD" > 2022-08-15 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>libuv</h3><div class="text-muted small"><p> Node 공식 문서의 블로킹 vs 논-블로킹 첫 문장이다. I/O는 주로 libuv가 지원하는 시스템 디스크나 네트워크와 상호작용하는 것을 가리킨다. libuv 문서 libuv가 먼저 무엇인지 살펴보자 위 링크를 타고 libuv로 들어가면 Asyncronous I/O made simple - libuv is a multi-plat...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/libuv/" class="btn btn-outline-primary" prompt="이전 글"><p>libuv</p></a> <a href="/posts/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%EC%9E%91/" class="btn btn-outline-primary" prompt="다음 글"><p>스프링 시작</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">sjungwon</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%EC%9E%90%EB%B0%94/">자바</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/%EA%B0%80%EB%B9%84%EC%A7%80%EC%BB%AC%EB%A0%89%ED%84%B0/">가비지컬렉터</a> <a class="post-tag" href="/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/">디자인패턴</a> <a class="post-tag" href="/tags/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C/">멀티스레드</a> <a class="post-tag" href="/tags/%ED%85%9C%ED%94%8C%EB%A6%BF%EB%A9%94%EC%86%8C%EB%93%9C/">템플릿메소드</a> <a class="post-tag" href="/tags/%ED%9B%85/">훅</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
